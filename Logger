import cv2 as cv
import mediapipe as mp
import copy
import itertools
import csv
import os
from model import KeyPointClassifier

# Initialize Mediapipe Hands
mp_hands = mp.solutions.hands
hands = mp_hands.Hands(max_num_hands=1, min_detection_confidence=0.7, min_tracking_confidence=0.7)
mp_drawing = mp.solutions.drawing_utils

# Load classifier (optional for live display)
keypoint_classifier = KeyPointClassifier()

current_class = None  # class number for logging
class_input = ""      # string buffer for multi-digit input

def calc_landmark_list(image, landmarks):
    image_width, image_height = image.shape[1], image.shape[0]
    landmark_point = []
    for landmark in landmarks.landmark:
        landmark_x = min(int(landmark.x * image_width), image_width - 1)
        landmark_y = min(int(landmark.y * image_height), image_height - 1)
        landmark_point.append([landmark_x, landmark_y])
    return landmark_point

def pre_process_landmark(landmark_list):
    temp_landmark_list = copy.deepcopy(landmark_list)
    base_x, base_y = temp_landmark_list[0]
    for index, landmark_point in enumerate(temp_landmark_list):
        temp_landmark_list[index][0] -= base_x
        temp_landmark_list[index][1] -= base_y
    temp_landmark_list = list(itertools.chain.from_iterable(temp_landmark_list))
    max_value = max(map(abs, temp_landmark_list))
    return [n / max_value for n in temp_landmark_list]

def save_landmarks(landmark_list, class_label):
    filename = "model/keypoint_classifier/keypoint.csv"  
    with open(filename, mode='a', newline='') as f:
        writer = csv.writer(f)
        writer.writerow([class_label] + landmark_list)  
    print(f"Saved landmarks to {filename} with class {class_label}")

# Open webcam
cap = cv.VideoCapture(0)
if not cap.isOpened():
    print("Failed to open camera")
    exit()

print("Press 'q' to quit, type class number + Enter to set class, press SPACE to log landmarks.")

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        print("Failed to grab frame")
        break

    frame = cv.flip(frame, 1)
    image = cv.cvtColor(frame, cv.COLOR_BGR2RGB)
    image.flags.writeable = False
    results = hands.process(image)
    image.flags.writeable = True

    hand_sign_text = ""
    pre_processed = None
    if results.multi_hand_landmarks:
        for hand_landmarks in results.multi_hand_landmarks:
            mp_drawing.draw_landmarks(frame, hand_landmarks, mp_hands.HAND_CONNECTIONS)
            landmark_list = calc_landmark_list(frame, hand_landmarks)
            pre_processed = pre_process_landmark(landmark_list)
            hand_sign_id = keypoint_classifier(pre_processed)

    # Display current input buffer and class
    cv.putText(frame, f"Class Input: {class_input}", (10, 30), cv.FONT_HERSHEY_SIMPLEX, 1, (0,255,0), 2)

    cv.imshow("Logging Mode", frame)
    key = cv.waitKey(1) & 0xFF

    if key == ord('q'):
        break
    elif key == ord(' '):
        if current_class is not None and pre_processed is not None:
            save_landmarks(pre_processed, current_class-1)
    elif key == 13:  # Enter key
        if class_input.isdigit():
            current_class = int(class_input)
            print(f"Current logging class set to {current_class}")
            class_input = ""  # reset input buffer
    elif 48 <= key <= 57:  # digits 0-9
        class_input += chr(key)
    elif key == 8:  # Backspace
        class_input = class_input[:-1]

cap.release()
cv.destroyAllWindows()
